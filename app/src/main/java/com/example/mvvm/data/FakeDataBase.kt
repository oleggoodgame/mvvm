package com.example.mvvm.data

import android.util.Log
//DAO (Data Access Object) — це паттерн проектування, який використовується для абстрагування і управління доступом до даних у програмі. DAO забезпечує інтерфейс для доступу до бази даних або інших джерел даних, таким чином розділяючи бізнес-логіку і доступ до даних.
//
//Основні принципи DAO
//Інтерфейс для доступу до даних: DAO надає методи для взаємодії з даними, такі як читання, запис, оновлення і видалення. Це дозволяє вашій бізнес-логіці взаємодіяти з даними без знання деталей їх зберігання.
//
//Інкапсуляція доступу до даних: DAO приховує деталі реалізації доступу до даних, такі як SQL-запити або запити до API, за інтерфейсом. Це спрощує зміну способу зберігання даних без впливу на решту програми.
//
//Сприяння тестуванню: Завдяки DAO легко замінювати реальні реалізації доступу до даних на підроблені або мок-реалізації для тестування.
// Призначення: Симулює базу даних для зберігання даних у пам'яті. Має тільки один екземпляр (singleton).
class FakeDatabase private constructor() {

    var quoteDao = FakeQuoteDao()
        private set
    // private set: Це специфікатор доступу для методу set. Він забороняє зовнішньому коду змінювати значення змінної quoteDao. Тільки сам клас FakeDatabase може змінювати значення цієї змінної.

    // companion object: Це спеціальний блок, який дозволяє створювати статичні методи та властивості для класу. Він працює як Singleton (одинарний екземпляр класу), де всі його методи і властивості є спільними для всіх екземплярів класу.
    companion object {
        //Volatile: Ця анотація використовується для того, щоб гарантувати, що зміни до змінної instance будуть видимі для всіх потоків. У випадку з багатопоточними програмами це забезпечує, що один потік, який змінює значення змінної, буде відразу видно іншим потокам.
        @Volatile private var instance: FakeDatabase? = null
        // instance ?: synchronized(this) { ... }: Перевіряє, чи є вже створений екземпляр класу FakeDatabase. Якщо так, він повертає існуючий екземпляр (instance). Якщо ні, виконує код у блоці synchronized(this).
        //
        //synchronized(this): Забезпечує, що блок коду виконується лише одним потоком одночасно, щоб уникнути створення кількох екземплярів класу у багатопоточному середовищі.
        //
        //instance ?: FakeDatabase().also { instance = it }: Якщо instance все ще null, створюється новий екземпляр FakeDatabase. also { instance = it } встановлює цю нову інстанцію у instance і повертає її.
        fun getInstance() =
            instance ?: synchronized(this) {
                instance ?: FakeDatabase().also { instance = it }
            }
        public fun get(): Unit{
            Log.d("FakeDataBase", "Fake Data Base create $instance")
        }
        //Таким чином, цей код забезпечує, що клас FakeDatabase має лише один екземпляр, і цей екземпляр є доступним всім частинам програми.
    }
}